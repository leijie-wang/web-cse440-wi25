"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/next-image-export-optimizer";
exports.ids = ["vendor-chunks/next-image-export-optimizer"];
exports.modules = {

/***/ "(ssr)/./node_modules/next-image-export-optimizer/dist/ExportedImage.js":
/*!************************************************************************!*\
  !*** ./node_modules/next-image-export-optimizer/dist/ExportedImage.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/image */ \"(ssr)/./node_modules/next/dist/api/image.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \n\nconst splitFilePath = ({ filePath })=>{\n    const filenameWithExtension = filePath.split(\"\\\\\").pop()?.split(\"/\").pop() || \"\";\n    const filePathWithoutFilename = filePath.split(filenameWithExtension).shift();\n    const fileExtension = filePath.split(\".\").pop();\n    const filenameWithoutExtension = filenameWithExtension.substring(0, filenameWithExtension.lastIndexOf(\".\")) || filenameWithExtension;\n    return {\n        path: filePathWithoutFilename,\n        filename: filenameWithoutExtension,\n        extension: fileExtension || \"\"\n    };\n};\nconst generateImageURL = (src, width, basePath, isRemoteImage = false)=>{\n    const { filename, path, extension } = splitFilePath({\n        filePath: src\n    });\n    const useWebp =  true ? \"true\" == \"true\" : 0;\n    if (![\n        \"JPG\",\n        \"JPEG\",\n        \"WEBP\",\n        \"PNG\",\n        \"AVIF\",\n        \"GIF\"\n    ].includes(extension.toUpperCase())) {\n        // The images has an unsupported extension\n        // We will return the src\n        return src;\n    }\n    // If the images are stored as WEBP by the package, then we should change\n    // the extension to WEBP to load them correctly\n    let processedExtension = extension;\n    if (useWebp && [\n        \"JPG\",\n        \"JPEG\",\n        \"PNG\",\n        \"GIF\"\n    ].includes(extension.toUpperCase())) {\n        processedExtension = \"WEBP\";\n    }\n    let correctedPath = path;\n    const lastChar = correctedPath?.substr(-1); // Selects the last character\n    if (lastChar != \"/\") {\n        // If the last character is not a slash\n        correctedPath = correctedPath + \"/\"; // Append a slash to it.\n    }\n    const isStaticImage = src.includes(\"_next/static/media\");\n    if (basePath) {\n        if (basePath.endsWith(\"/\") && correctedPath && correctedPath.startsWith(\"/\")) {\n            correctedPath = basePath + correctedPath.slice(1);\n        } else if (!basePath.endsWith(\"/\") && correctedPath && !correctedPath.startsWith(\"/\")) {\n            correctedPath = basePath + \"/\" + correctedPath;\n        } else {\n            correctedPath = basePath + correctedPath;\n        }\n    }\n    const exportFolderName = \"images-optimized\" || 0;\n    const basePathPrefixForStaticImages = basePath ? basePath + \"/\" : \"\";\n    let generatedImageURL = `${isStaticImage ? basePathPrefixForStaticImages : correctedPath}${exportFolderName}/${filename}-opt-${width}.${processedExtension.toUpperCase()}`;\n    // if the generatedImageURL is not starting with a slash, then we add one as long as it is not a remote image\n    if (!isRemoteImage && generatedImageURL.charAt(0) !== \"/\") {\n        generatedImageURL = \"/\" + generatedImageURL;\n    }\n    return generatedImageURL;\n};\n// Credits to https://github.com/bryc/code/blob/master/jshash/experimental/cyrb53.js\n// This is a hash function that is used to generate a hash from the image URL\nconst hashAlgorithm = (str, seed = 0)=>{\n    let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;\n    for(let i = 0, ch; i < str.length; i++){\n        ch = str.charCodeAt(i);\n        h1 = Math.imul(h1 ^ ch, 2654435761);\n        h2 = Math.imul(h2 ^ ch, 1597334677);\n    }\n    h1 = Math.imul(h1 ^ h1 >>> 16, 2246822507);\n    h1 ^= Math.imul(h2 ^ h2 >>> 13, 3266489909);\n    h2 = Math.imul(h2 ^ h2 >>> 16, 2246822507);\n    h2 ^= Math.imul(h1 ^ h1 >>> 13, 3266489909);\n    return 4294967296 * (2097151 & h2) + (h1 >>> 0);\n};\nfunction urlToFilename(url) {\n    try {\n        const parsedUrl = new URL(url);\n        const extension = parsedUrl.pathname.split(\".\").pop();\n        if (extension) {\n            return hashAlgorithm(url).toString().concat(\".\", extension);\n        }\n    } catch (error) {\n        console.error(\"Error parsing URL\", url, error);\n    }\n    return hashAlgorithm(url).toString();\n}\nconst imageURLForRemoteImage = ({ src, width, basePath })=>{\n    const encodedSrc = urlToFilename(src);\n    return generateImageURL(encodedSrc, width, basePath, true);\n};\nconst optimizedLoader = ({ src, width, basePath })=>{\n    const isStaticImage = typeof src === \"object\";\n    const _src = isStaticImage ? src.src : src;\n    const originalImageWidth = isStaticImage && src.width || undefined;\n    // if it is a static image, we can use the width of the original image to generate a reduced srcset that returns\n    // the same image url for widths that are larger than the original image\n    if (isStaticImage && originalImageWidth && width > originalImageWidth) {\n        const deviceSizes = ({\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image/\",\"loader\":\"custom\",\"dangerouslyAllowSVG\":false,\"unoptimized\":false,\"domains\":[],\"remotePatterns\":[],\"output\":\"export\"}?.deviceSizes || [\n            640,\n            750,\n            828,\n            1080,\n            1200,\n            1920,\n            2048,\n            3840\n        ]).map(Number);\n        const imageSizes = ({\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image/\",\"loader\":\"custom\",\"dangerouslyAllowSVG\":false,\"unoptimized\":false,\"domains\":[],\"remotePatterns\":[],\"output\":\"export\"}?.imageSizes || [\n            16,\n            32,\n            48,\n            64,\n            96,\n            128,\n            256,\n            384\n        ]).map(Number);\n        let allSizes = [\n            ...deviceSizes,\n            ...imageSizes\n        ];\n        allSizes = allSizes.filter((v, i, a)=>a.indexOf(v) === i);\n        allSizes.sort((a, b)=>a - b);\n        // only use the width if it is smaller or equal to the next size in the allSizes array\n        let nextLargestSize = null;\n        for(let i = 0; i < allSizes.length; i++){\n            if (Number(allSizes[i]) >= originalImageWidth && (nextLargestSize === null || Number(allSizes[i]) < nextLargestSize)) {\n                nextLargestSize = Number(allSizes[i]);\n            }\n        }\n        if (nextLargestSize !== null) {\n            return generateImageURL(_src, nextLargestSize, basePath);\n        }\n    }\n    // Check if the image is a remote image (starts with http or https)\n    if (_src.startsWith(\"http\")) {\n        return imageURLForRemoteImage({\n            src: _src,\n            width,\n            basePath\n        });\n    }\n    return generateImageURL(_src, width, basePath);\n};\nconst fallbackLoader = ({ src })=>{\n    let _src = typeof src === \"object\" ? src.src : src;\n    const isRemoteImage = _src.startsWith(\"http\");\n    // if the _src does not start with a slash, then we add one as long as it is not a remote image\n    if (!isRemoteImage && _src.charAt(0) !== \"/\") {\n        _src = \"/\" + _src;\n    }\n    return _src;\n};\nconst ExportedImage = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(({ src, priority = false, loading, className, width, height, onLoad, unoptimized, placeholder = \"blur\", basePath = \"\", alt = \"\", blurDataURL, style, onError, overrideSrc, ...rest }, ref)=>{\n    const [imageError, setImageError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const automaticallyCalculatedBlurDataURL = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        if (blurDataURL) {\n            // use the user provided blurDataURL if present\n            return blurDataURL;\n        }\n        // check if the src is specified as a local file -> then it is an object\n        const isStaticImage = typeof src === \"object\";\n        let _src = isStaticImage ? src.src : src;\n        if (unoptimized === true) {\n            // return the src image when unoptimized\n            return _src;\n        }\n        // Check if the image is a remote image (starts with http or https)\n        if (_src.startsWith(\"http\")) {\n            return imageURLForRemoteImage({\n                src: _src,\n                width: 10,\n                basePath\n            });\n        }\n        // otherwise use the generated image of 10px width as a blurDataURL\n        return generateImageURL(_src, 10, basePath);\n    }, [\n        blurDataURL,\n        src,\n        unoptimized,\n        basePath\n    ]);\n    // check if the src is a SVG image -> then we should not use the blurDataURL and use unoptimized\n    const isSVG = typeof src === \"object\" ? src.src.endsWith(\".svg\") : src.endsWith(\".svg\");\n    const [blurComplete, setBlurComplete] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Currently, we have to handle the blurDataURL ourselves as the new Image component\n    // is expecting a base64 encoded string, but the generated blurDataURL is a normal URL\n    const blurStyle = placeholder === \"blur\" && !isSVG && automaticallyCalculatedBlurDataURL && automaticallyCalculatedBlurDataURL.startsWith(\"/\") && !blurComplete ? {\n        backgroundSize: style?.objectFit || \"cover\",\n        backgroundPosition: style?.objectPosition || \"50% 50%\",\n        backgroundRepeat: \"no-repeat\",\n        backgroundImage: `url(\"${automaticallyCalculatedBlurDataURL}\")`\n    } : undefined;\n    const isStaticImage = typeof src === \"object\";\n    let _src = isStaticImage ? src.src : src;\n    if (basePath && !isStaticImage && _src.startsWith(\"/\")) {\n        _src = basePath + _src;\n    }\n    if (basePath && !isStaticImage && !_src.startsWith(\"/\")) {\n        _src = basePath + \"/\" + _src;\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(next_image__WEBPACK_IMPORTED_MODULE_0__[\"default\"], {\n        ref: ref,\n        alt: alt,\n        ...rest,\n        ...width && {\n            width\n        },\n        ...height && {\n            height\n        },\n        ...loading && {\n            loading\n        },\n        ...className && {\n            className\n        },\n        ...onLoad && {\n            onLoad\n        },\n        ...overrideSrc && {\n            overrideSrc\n        },\n        ...placeholder && {\n            placeholder: blurStyle || blurComplete ? \"empty\" : placeholder\n        },\n        ...unoptimized && {\n            unoptimized\n        },\n        ...priority && {\n            priority\n        },\n        ...isSVG && {\n            unoptimized: true\n        },\n        style: {\n            ...style,\n            ...blurStyle\n        },\n        loader: imageError || unoptimized === true ? ()=>fallbackLoader({\n                src: overrideSrc || src\n            }) : (e)=>optimizedLoader({\n                src,\n                width: e.width,\n                basePath\n            }),\n        blurDataURL: automaticallyCalculatedBlurDataURL,\n        onError: (error)=>{\n            setImageError(true);\n            setBlurComplete(true);\n            // execute the onError function if provided\n            onError && onError(error);\n        },\n        onLoad: (e)=>{\n            // for some configurations, the onError handler is not called on an error occurrence\n            // so we need to check if the image is loaded correctly\n            const target = e.target;\n            if (target.naturalWidth === 0) {\n                // Broken image, fall back to unoptimized (meaning the original image src)\n                setImageError(true);\n            }\n            setBlurComplete(true);\n            // execute the onLoad callback if present\n            onLoad && onLoad(e);\n        },\n        src: isStaticImage ? src : _src\n    });\n});\nExportedImage.displayName = \"ExportedImage\";\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ExportedImage);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC1pbWFnZS1leHBvcnQtb3B0aW1pemVyL2Rpc3QvRXhwb3J0ZWRJbWFnZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OzZEQUMrQjtBQUM4QjtBQUM3RCxNQUFNSyxnQkFBZ0IsQ0FBQyxFQUFFQyxRQUFRLEVBQUU7SUFDL0IsTUFBTUMsd0JBQXdCRCxTQUFTRSxLQUFLLENBQUMsTUFBTUMsR0FBRyxJQUFJRCxNQUFNLEtBQUtDLFNBQVM7SUFDOUUsTUFBTUMsMEJBQTBCSixTQUFTRSxLQUFLLENBQUNELHVCQUF1QkksS0FBSztJQUMzRSxNQUFNQyxnQkFBZ0JOLFNBQVNFLEtBQUssQ0FBQyxLQUFLQyxHQUFHO0lBQzdDLE1BQU1JLDJCQUEyQk4sc0JBQXNCTyxTQUFTLENBQUMsR0FBR1Asc0JBQXNCUSxXQUFXLENBQUMsU0FBU1I7SUFDL0csT0FBTztRQUNIUyxNQUFNTjtRQUNOTyxVQUFVSjtRQUNWSyxXQUFXTixpQkFBaUI7SUFDaEM7QUFDSjtBQUNBLE1BQU1PLG1CQUFtQixDQUFDQyxLQUFLQyxPQUFPQyxVQUFVQyxnQkFBZ0IsS0FBSztJQUNqRSxNQUFNLEVBQUVOLFFBQVEsRUFBRUQsSUFBSSxFQUFFRSxTQUFTLEVBQUUsR0FBR2IsY0FBYztRQUFFQyxVQUFVYztJQUFJO0lBQ3BFLE1BQU1JLFVBQVVDLEtBQXFFRyxHQUMvRUgsTUFBd0QsSUFBSSxTQUM1RCxDQUFJO0lBQ1YsSUFBSSxDQUFDO1FBQUM7UUFBTztRQUFRO1FBQVE7UUFBTztRQUFRO0tBQU0sQ0FBQ0ksUUFBUSxDQUFDWCxVQUFVWSxXQUFXLEtBQUs7UUFDbEYsMENBQTBDO1FBQzFDLHlCQUF5QjtRQUN6QixPQUFPVjtJQUNYO0lBQ0EseUVBQXlFO0lBQ3pFLCtDQUErQztJQUMvQyxJQUFJVyxxQkFBcUJiO0lBQ3pCLElBQUlNLFdBQ0E7UUFBQztRQUFPO1FBQVE7UUFBTztLQUFNLENBQUNLLFFBQVEsQ0FBQ1gsVUFBVVksV0FBVyxLQUFLO1FBQ2pF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ZWpDLGFBQWFBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWItY3NlNDQwLTI0d2kvLi9ub2RlX21vZHVsZXMvbmV4dC1pbWFnZS1leHBvcnQtb3B0aW1pemVyL2Rpc3QvRXhwb3J0ZWRJbWFnZS5qcz9lZjAzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuaW1wb3J0IEltYWdlIGZyb20gXCJuZXh0L2ltYWdlXCI7XG5pbXBvcnQgUmVhY3QsIHsgZm9yd2FyZFJlZiwgdXNlTWVtbywgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbmNvbnN0IHNwbGl0RmlsZVBhdGggPSAoeyBmaWxlUGF0aCB9KSA9PiB7XG4gICAgY29uc3QgZmlsZW5hbWVXaXRoRXh0ZW5zaW9uID0gZmlsZVBhdGguc3BsaXQoXCJcXFxcXCIpLnBvcCgpPy5zcGxpdChcIi9cIikucG9wKCkgfHwgXCJcIjtcbiAgICBjb25zdCBmaWxlUGF0aFdpdGhvdXRGaWxlbmFtZSA9IGZpbGVQYXRoLnNwbGl0KGZpbGVuYW1lV2l0aEV4dGVuc2lvbikuc2hpZnQoKTtcbiAgICBjb25zdCBmaWxlRXh0ZW5zaW9uID0gZmlsZVBhdGguc3BsaXQoXCIuXCIpLnBvcCgpO1xuICAgIGNvbnN0IGZpbGVuYW1lV2l0aG91dEV4dGVuc2lvbiA9IGZpbGVuYW1lV2l0aEV4dGVuc2lvbi5zdWJzdHJpbmcoMCwgZmlsZW5hbWVXaXRoRXh0ZW5zaW9uLmxhc3RJbmRleE9mKFwiLlwiKSkgfHwgZmlsZW5hbWVXaXRoRXh0ZW5zaW9uO1xuICAgIHJldHVybiB7XG4gICAgICAgIHBhdGg6IGZpbGVQYXRoV2l0aG91dEZpbGVuYW1lLFxuICAgICAgICBmaWxlbmFtZTogZmlsZW5hbWVXaXRob3V0RXh0ZW5zaW9uLFxuICAgICAgICBleHRlbnNpb246IGZpbGVFeHRlbnNpb24gfHwgXCJcIixcbiAgICB9O1xufTtcbmNvbnN0IGdlbmVyYXRlSW1hZ2VVUkwgPSAoc3JjLCB3aWR0aCwgYmFzZVBhdGgsIGlzUmVtb3RlSW1hZ2UgPSBmYWxzZSkgPT4ge1xuICAgIGNvbnN0IHsgZmlsZW5hbWUsIHBhdGgsIGV4dGVuc2lvbiB9ID0gc3BsaXRGaWxlUGF0aCh7IGZpbGVQYXRoOiBzcmMgfSk7XG4gICAgY29uc3QgdXNlV2VicCA9IHByb2Nlc3MuZW52Lm5leHRJbWFnZUV4cG9ydE9wdGltaXplcl9zdG9yZVBpY3R1cmVzSW5XRUJQICE9IHVuZGVmaW5lZFxuICAgICAgICA/IHByb2Nlc3MuZW52Lm5leHRJbWFnZUV4cG9ydE9wdGltaXplcl9zdG9yZVBpY3R1cmVzSW5XRUJQID09IFwidHJ1ZVwiXG4gICAgICAgIDogdHJ1ZTtcbiAgICBpZiAoIVtcIkpQR1wiLCBcIkpQRUdcIiwgXCJXRUJQXCIsIFwiUE5HXCIsIFwiQVZJRlwiLCBcIkdJRlwiXS5pbmNsdWRlcyhleHRlbnNpb24udG9VcHBlckNhc2UoKSkpIHtcbiAgICAgICAgLy8gVGhlIGltYWdlcyBoYXMgYW4gdW5zdXBwb3J0ZWQgZXh0ZW5zaW9uXG4gICAgICAgIC8vIFdlIHdpbGwgcmV0dXJuIHRoZSBzcmNcbiAgICAgICAgcmV0dXJuIHNyYztcbiAgICB9XG4gICAgLy8gSWYgdGhlIGltYWdlcyBhcmUgc3RvcmVkIGFzIFdFQlAgYnkgdGhlIHBhY2thZ2UsIHRoZW4gd2Ugc2hvdWxkIGNoYW5nZVxuICAgIC8vIHRoZSBleHRlbnNpb24gdG8gV0VCUCB0byBsb2FkIHRoZW0gY29ycmVjdGx5XG4gICAgbGV0IHByb2Nlc3NlZEV4dGVuc2lvbiA9IGV4dGVuc2lvbjtcbiAgICBpZiAodXNlV2VicCAmJlxuICAgICAgICBbXCJKUEdcIiwgXCJKUEVHXCIsIFwiUE5HXCIsIFwiR0lGXCJdLmluY2x1ZGVzKGV4dGVuc2lvbi50b1VwcGVyQ2FzZSgpKSkge1xuICAgICAgICBwcm9jZXNzZWRFeHRlbnNpb24gPSBcIldFQlBcIjtcbiAgICB9XG4gICAgbGV0IGNvcnJlY3RlZFBhdGggPSBwYXRoO1xuICAgIGNvbnN0IGxhc3RDaGFyID0gY29ycmVjdGVkUGF0aD8uc3Vic3RyKC0xKTsgLy8gU2VsZWN0cyB0aGUgbGFzdCBjaGFyYWN0ZXJcbiAgICBpZiAobGFzdENoYXIgIT0gXCIvXCIpIHtcbiAgICAgICAgLy8gSWYgdGhlIGxhc3QgY2hhcmFjdGVyIGlzIG5vdCBhIHNsYXNoXG4gICAgICAgIGNvcnJlY3RlZFBhdGggPSBjb3JyZWN0ZWRQYXRoICsgXCIvXCI7IC8vIEFwcGVuZCBhIHNsYXNoIHRvIGl0LlxuICAgIH1cbiAgICBjb25zdCBpc1N0YXRpY0ltYWdlID0gc3JjLmluY2x1ZGVzKFwiX25leHQvc3RhdGljL21lZGlhXCIpO1xuICAgIGlmIChiYXNlUGF0aCkge1xuICAgICAgICBpZiAoYmFzZVBhdGguZW5kc1dpdGgoXCIvXCIpICYmXG4gICAgICAgICAgICBjb3JyZWN0ZWRQYXRoICYmXG4gICAgICAgICAgICBjb3JyZWN0ZWRQYXRoLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgICAgICAgICBjb3JyZWN0ZWRQYXRoID0gYmFzZVBhdGggKyBjb3JyZWN0ZWRQYXRoLnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFiYXNlUGF0aC5lbmRzV2l0aChcIi9cIikgJiZcbiAgICAgICAgICAgIGNvcnJlY3RlZFBhdGggJiZcbiAgICAgICAgICAgICFjb3JyZWN0ZWRQYXRoLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgICAgICAgICBjb3JyZWN0ZWRQYXRoID0gYmFzZVBhdGggKyBcIi9cIiArIGNvcnJlY3RlZFBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb3JyZWN0ZWRQYXRoID0gYmFzZVBhdGggKyBjb3JyZWN0ZWRQYXRoO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGV4cG9ydEZvbGRlck5hbWUgPSBwcm9jZXNzLmVudi5uZXh0SW1hZ2VFeHBvcnRPcHRpbWl6ZXJfZXhwb3J0Rm9sZGVyTmFtZSB8fFxuICAgICAgICBcIm5leHRJbWFnZUV4cG9ydE9wdGltaXplclwiO1xuICAgIGNvbnN0IGJhc2VQYXRoUHJlZml4Rm9yU3RhdGljSW1hZ2VzID0gYmFzZVBhdGggPyBiYXNlUGF0aCArIFwiL1wiIDogXCJcIjtcbiAgICBsZXQgZ2VuZXJhdGVkSW1hZ2VVUkwgPSBgJHtpc1N0YXRpY0ltYWdlID8gYmFzZVBhdGhQcmVmaXhGb3JTdGF0aWNJbWFnZXMgOiBjb3JyZWN0ZWRQYXRofSR7ZXhwb3J0Rm9sZGVyTmFtZX0vJHtmaWxlbmFtZX0tb3B0LSR7d2lkdGh9LiR7cHJvY2Vzc2VkRXh0ZW5zaW9uLnRvVXBwZXJDYXNlKCl9YDtcbiAgICAvLyBpZiB0aGUgZ2VuZXJhdGVkSW1hZ2VVUkwgaXMgbm90IHN0YXJ0aW5nIHdpdGggYSBzbGFzaCwgdGhlbiB3ZSBhZGQgb25lIGFzIGxvbmcgYXMgaXQgaXMgbm90IGEgcmVtb3RlIGltYWdlXG4gICAgaWYgKCFpc1JlbW90ZUltYWdlICYmIGdlbmVyYXRlZEltYWdlVVJMLmNoYXJBdCgwKSAhPT0gXCIvXCIpIHtcbiAgICAgICAgZ2VuZXJhdGVkSW1hZ2VVUkwgPSBcIi9cIiArIGdlbmVyYXRlZEltYWdlVVJMO1xuICAgIH1cbiAgICByZXR1cm4gZ2VuZXJhdGVkSW1hZ2VVUkw7XG59O1xuLy8gQ3JlZGl0cyB0byBodHRwczovL2dpdGh1Yi5jb20vYnJ5Yy9jb2RlL2Jsb2IvbWFzdGVyL2pzaGFzaC9leHBlcmltZW50YWwvY3lyYjUzLmpzXG4vLyBUaGlzIGlzIGEgaGFzaCBmdW5jdGlvbiB0aGF0IGlzIHVzZWQgdG8gZ2VuZXJhdGUgYSBoYXNoIGZyb20gdGhlIGltYWdlIFVSTFxuY29uc3QgaGFzaEFsZ29yaXRobSA9IChzdHIsIHNlZWQgPSAwKSA9PiB7XG4gICAgbGV0IGgxID0gMHhkZWFkYmVlZiBeIHNlZWQsIGgyID0gMHg0MWM2Y2U1NyBeIHNlZWQ7XG4gICAgZm9yIChsZXQgaSA9IDAsIGNoOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGgxID0gTWF0aC5pbXVsKGgxIF4gY2gsIDI2NTQ0MzU3NjEpO1xuICAgICAgICBoMiA9IE1hdGguaW11bChoMiBeIGNoLCAxNTk3MzM0Njc3KTtcbiAgICB9XG4gICAgaDEgPSBNYXRoLmltdWwoaDEgXiAoaDEgPj4+IDE2KSwgMjI0NjgyMjUwNyk7XG4gICAgaDEgXj0gTWF0aC5pbXVsKGgyIF4gKGgyID4+PiAxMyksIDMyNjY0ODk5MDkpO1xuICAgIGgyID0gTWF0aC5pbXVsKGgyIF4gKGgyID4+PiAxNiksIDIyNDY4MjI1MDcpO1xuICAgIGgyIF49IE1hdGguaW11bChoMSBeIChoMSA+Pj4gMTMpLCAzMjY2NDg5OTA5KTtcbiAgICByZXR1cm4gNDI5NDk2NzI5NiAqICgyMDk3MTUxICYgaDIpICsgKGgxID4+PiAwKTtcbn07XG5mdW5jdGlvbiB1cmxUb0ZpbGVuYW1lKHVybCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFVybCA9IG5ldyBVUkwodXJsKTtcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9uID0gcGFyc2VkVXJsLnBhdGhuYW1lLnNwbGl0KFwiLlwiKS5wb3AoKTtcbiAgICAgICAgaWYgKGV4dGVuc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIGhhc2hBbGdvcml0aG0odXJsKS50b1N0cmluZygpLmNvbmNhdChcIi5cIiwgZXh0ZW5zaW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHBhcnNpbmcgVVJMXCIsIHVybCwgZXJyb3IpO1xuICAgIH1cbiAgICByZXR1cm4gaGFzaEFsZ29yaXRobSh1cmwpLnRvU3RyaW5nKCk7XG59XG5jb25zdCBpbWFnZVVSTEZvclJlbW90ZUltYWdlID0gKHsgc3JjLCB3aWR0aCwgYmFzZVBhdGgsIH0pID0+IHtcbiAgICBjb25zdCBlbmNvZGVkU3JjID0gdXJsVG9GaWxlbmFtZShzcmMpO1xuICAgIHJldHVybiBnZW5lcmF0ZUltYWdlVVJMKGVuY29kZWRTcmMsIHdpZHRoLCBiYXNlUGF0aCwgdHJ1ZSk7XG59O1xuY29uc3Qgb3B0aW1pemVkTG9hZGVyID0gKHsgc3JjLCB3aWR0aCwgYmFzZVBhdGgsIH0pID0+IHtcbiAgICBjb25zdCBpc1N0YXRpY0ltYWdlID0gdHlwZW9mIHNyYyA9PT0gXCJvYmplY3RcIjtcbiAgICBjb25zdCBfc3JjID0gaXNTdGF0aWNJbWFnZSA/IHNyYy5zcmMgOiBzcmM7XG4gICAgY29uc3Qgb3JpZ2luYWxJbWFnZVdpZHRoID0gKGlzU3RhdGljSW1hZ2UgJiYgc3JjLndpZHRoKSB8fCB1bmRlZmluZWQ7XG4gICAgLy8gaWYgaXQgaXMgYSBzdGF0aWMgaW1hZ2UsIHdlIGNhbiB1c2UgdGhlIHdpZHRoIG9mIHRoZSBvcmlnaW5hbCBpbWFnZSB0byBnZW5lcmF0ZSBhIHJlZHVjZWQgc3Jjc2V0IHRoYXQgcmV0dXJuc1xuICAgIC8vIHRoZSBzYW1lIGltYWdlIHVybCBmb3Igd2lkdGhzIHRoYXQgYXJlIGxhcmdlciB0aGFuIHRoZSBvcmlnaW5hbCBpbWFnZVxuICAgIGlmIChpc1N0YXRpY0ltYWdlICYmIG9yaWdpbmFsSW1hZ2VXaWR0aCAmJiB3aWR0aCA+IG9yaWdpbmFsSW1hZ2VXaWR0aCkge1xuICAgICAgICBjb25zdCBkZXZpY2VTaXplcyA9IChwcm9jZXNzLmVudi5fX05FWFRfSU1BR0VfT1BUUz8uZGV2aWNlU2l6ZXMgfHwgW1xuICAgICAgICAgICAgNjQwLCA3NTAsIDgyOCwgMTA4MCwgMTIwMCwgMTkyMCwgMjA0OCwgMzg0MCxcbiAgICAgICAgXSkubWFwKE51bWJlcik7XG4gICAgICAgIGNvbnN0IGltYWdlU2l6ZXMgPSAocHJvY2Vzcy5lbnYuX19ORVhUX0lNQUdFX09QVFM/LmltYWdlU2l6ZXMgfHwgW1xuICAgICAgICAgICAgMTYsIDMyLCA0OCwgNjQsIDk2LCAxMjgsIDI1NiwgMzg0LFxuICAgICAgICBdKS5tYXAoTnVtYmVyKTtcbiAgICAgICAgbGV0IGFsbFNpemVzID0gWy4uLmRldmljZVNpemVzLCAuLi5pbWFnZVNpemVzXTtcbiAgICAgICAgYWxsU2l6ZXMgPSBhbGxTaXplcy5maWx0ZXIoKHYsIGksIGEpID0+IGEuaW5kZXhPZih2KSA9PT0gaSk7XG4gICAgICAgIGFsbFNpemVzLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgICAgICAgLy8gb25seSB1c2UgdGhlIHdpZHRoIGlmIGl0IGlzIHNtYWxsZXIgb3IgZXF1YWwgdG8gdGhlIG5leHQgc2l6ZSBpbiB0aGUgYWxsU2l6ZXMgYXJyYXlcbiAgICAgICAgbGV0IG5leHRMYXJnZXN0U2l6ZSA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWxsU2l6ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChOdW1iZXIoYWxsU2l6ZXNbaV0pID49IG9yaWdpbmFsSW1hZ2VXaWR0aCAmJlxuICAgICAgICAgICAgICAgIChuZXh0TGFyZ2VzdFNpemUgPT09IG51bGwgfHwgTnVtYmVyKGFsbFNpemVzW2ldKSA8IG5leHRMYXJnZXN0U2l6ZSkpIHtcbiAgICAgICAgICAgICAgICBuZXh0TGFyZ2VzdFNpemUgPSBOdW1iZXIoYWxsU2l6ZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0TGFyZ2VzdFNpemUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZUltYWdlVVJMKF9zcmMsIG5leHRMYXJnZXN0U2l6ZSwgYmFzZVBhdGgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIENoZWNrIGlmIHRoZSBpbWFnZSBpcyBhIHJlbW90ZSBpbWFnZSAoc3RhcnRzIHdpdGggaHR0cCBvciBodHRwcylcbiAgICBpZiAoX3NyYy5zdGFydHNXaXRoKFwiaHR0cFwiKSkge1xuICAgICAgICByZXR1cm4gaW1hZ2VVUkxGb3JSZW1vdGVJbWFnZSh7IHNyYzogX3NyYywgd2lkdGgsIGJhc2VQYXRoIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZ2VuZXJhdGVJbWFnZVVSTChfc3JjLCB3aWR0aCwgYmFzZVBhdGgpO1xufTtcbmNvbnN0IGZhbGxiYWNrTG9hZGVyID0gKHsgc3JjIH0pID0+IHtcbiAgICBsZXQgX3NyYyA9IHR5cGVvZiBzcmMgPT09IFwib2JqZWN0XCIgPyBzcmMuc3JjIDogc3JjO1xuICAgIGNvbnN0IGlzUmVtb3RlSW1hZ2UgPSBfc3JjLnN0YXJ0c1dpdGgoXCJodHRwXCIpO1xuICAgIC8vIGlmIHRoZSBfc3JjIGRvZXMgbm90IHN0YXJ0IHdpdGggYSBzbGFzaCwgdGhlbiB3ZSBhZGQgb25lIGFzIGxvbmcgYXMgaXQgaXMgbm90IGEgcmVtb3RlIGltYWdlXG4gICAgaWYgKCFpc1JlbW90ZUltYWdlICYmIF9zcmMuY2hhckF0KDApICE9PSBcIi9cIikge1xuICAgICAgICBfc3JjID0gXCIvXCIgKyBfc3JjO1xuICAgIH1cbiAgICByZXR1cm4gX3NyYztcbn07XG5jb25zdCBFeHBvcnRlZEltYWdlID0gZm9yd2FyZFJlZigoeyBzcmMsIHByaW9yaXR5ID0gZmFsc2UsIGxvYWRpbmcsIGNsYXNzTmFtZSwgd2lkdGgsIGhlaWdodCwgb25Mb2FkLCB1bm9wdGltaXplZCwgcGxhY2Vob2xkZXIgPSBcImJsdXJcIiwgYmFzZVBhdGggPSBcIlwiLCBhbHQgPSBcIlwiLCBibHVyRGF0YVVSTCwgc3R5bGUsIG9uRXJyb3IsIG92ZXJyaWRlU3JjLCAuLi5yZXN0IH0sIHJlZikgPT4ge1xuICAgIGNvbnN0IFtpbWFnZUVycm9yLCBzZXRJbWFnZUVycm9yXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBhdXRvbWF0aWNhbGx5Q2FsY3VsYXRlZEJsdXJEYXRhVVJMID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmIChibHVyRGF0YVVSTCkge1xuICAgICAgICAgICAgLy8gdXNlIHRoZSB1c2VyIHByb3ZpZGVkIGJsdXJEYXRhVVJMIGlmIHByZXNlbnRcbiAgICAgICAgICAgIHJldHVybiBibHVyRGF0YVVSTDtcbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayBpZiB0aGUgc3JjIGlzIHNwZWNpZmllZCBhcyBhIGxvY2FsIGZpbGUgLT4gdGhlbiBpdCBpcyBhbiBvYmplY3RcbiAgICAgICAgY29uc3QgaXNTdGF0aWNJbWFnZSA9IHR5cGVvZiBzcmMgPT09IFwib2JqZWN0XCI7XG4gICAgICAgIGxldCBfc3JjID0gaXNTdGF0aWNJbWFnZSA/IHNyYy5zcmMgOiBzcmM7XG4gICAgICAgIGlmICh1bm9wdGltaXplZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgLy8gcmV0dXJuIHRoZSBzcmMgaW1hZ2Ugd2hlbiB1bm9wdGltaXplZFxuICAgICAgICAgICAgcmV0dXJuIF9zcmM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGltYWdlIGlzIGEgcmVtb3RlIGltYWdlIChzdGFydHMgd2l0aCBodHRwIG9yIGh0dHBzKVxuICAgICAgICBpZiAoX3NyYy5zdGFydHNXaXRoKFwiaHR0cFwiKSkge1xuICAgICAgICAgICAgcmV0dXJuIGltYWdlVVJMRm9yUmVtb3RlSW1hZ2UoeyBzcmM6IF9zcmMsIHdpZHRoOiAxMCwgYmFzZVBhdGggfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3RoZXJ3aXNlIHVzZSB0aGUgZ2VuZXJhdGVkIGltYWdlIG9mIDEwcHggd2lkdGggYXMgYSBibHVyRGF0YVVSTFxuICAgICAgICByZXR1cm4gZ2VuZXJhdGVJbWFnZVVSTChfc3JjLCAxMCwgYmFzZVBhdGgpO1xuICAgIH0sIFtibHVyRGF0YVVSTCwgc3JjLCB1bm9wdGltaXplZCwgYmFzZVBhdGhdKTtcbiAgICAvLyBjaGVjayBpZiB0aGUgc3JjIGlzIGEgU1ZHIGltYWdlIC0+IHRoZW4gd2Ugc2hvdWxkIG5vdCB1c2UgdGhlIGJsdXJEYXRhVVJMIGFuZCB1c2UgdW5vcHRpbWl6ZWRcbiAgICBjb25zdCBpc1NWRyA9IHR5cGVvZiBzcmMgPT09IFwib2JqZWN0XCIgPyBzcmMuc3JjLmVuZHNXaXRoKFwiLnN2Z1wiKSA6IHNyYy5lbmRzV2l0aChcIi5zdmdcIik7XG4gICAgY29uc3QgW2JsdXJDb21wbGV0ZSwgc2V0Qmx1ckNvbXBsZXRlXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICAvLyBDdXJyZW50bHksIHdlIGhhdmUgdG8gaGFuZGxlIHRoZSBibHVyRGF0YVVSTCBvdXJzZWx2ZXMgYXMgdGhlIG5ldyBJbWFnZSBjb21wb25lbnRcbiAgICAvLyBpcyBleHBlY3RpbmcgYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcsIGJ1dCB0aGUgZ2VuZXJhdGVkIGJsdXJEYXRhVVJMIGlzIGEgbm9ybWFsIFVSTFxuICAgIGNvbnN0IGJsdXJTdHlsZSA9IHBsYWNlaG9sZGVyID09PSBcImJsdXJcIiAmJlxuICAgICAgICAhaXNTVkcgJiZcbiAgICAgICAgYXV0b21hdGljYWxseUNhbGN1bGF0ZWRCbHVyRGF0YVVSTCAmJlxuICAgICAgICBhdXRvbWF0aWNhbGx5Q2FsY3VsYXRlZEJsdXJEYXRhVVJMLnN0YXJ0c1dpdGgoXCIvXCIpICYmXG4gICAgICAgICFibHVyQ29tcGxldGVcbiAgICAgICAgPyB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kU2l6ZTogc3R5bGU/Lm9iamVjdEZpdCB8fCBcImNvdmVyXCIsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kUG9zaXRpb246IHN0eWxlPy5vYmplY3RQb3NpdGlvbiB8fCBcIjUwJSA1MCVcIixcbiAgICAgICAgICAgIGJhY2tncm91bmRSZXBlYXQ6IFwibm8tcmVwZWF0XCIsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IGB1cmwoXCIke2F1dG9tYXRpY2FsbHlDYWxjdWxhdGVkQmx1ckRhdGFVUkx9XCIpYCxcbiAgICAgICAgfVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBpc1N0YXRpY0ltYWdlID0gdHlwZW9mIHNyYyA9PT0gXCJvYmplY3RcIjtcbiAgICBsZXQgX3NyYyA9IGlzU3RhdGljSW1hZ2UgPyBzcmMuc3JjIDogc3JjO1xuICAgIGlmIChiYXNlUGF0aCAmJiAhaXNTdGF0aWNJbWFnZSAmJiBfc3JjLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgICAgIF9zcmMgPSBiYXNlUGF0aCArIF9zcmM7XG4gICAgfVxuICAgIGlmIChiYXNlUGF0aCAmJiAhaXNTdGF0aWNJbWFnZSAmJiAhX3NyYy5zdGFydHNXaXRoKFwiL1wiKSkge1xuICAgICAgICBfc3JjID0gYmFzZVBhdGggKyBcIi9cIiArIF9zcmM7XG4gICAgfVxuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChJbWFnZSwgeyByZWY6IHJlZiwgYWx0OiBhbHQsIC4uLnJlc3QsIC4uLih3aWR0aCAmJiB7IHdpZHRoIH0pLCAuLi4oaGVpZ2h0ICYmIHsgaGVpZ2h0IH0pLCAuLi4obG9hZGluZyAmJiB7IGxvYWRpbmcgfSksIC4uLihjbGFzc05hbWUgJiYgeyBjbGFzc05hbWUgfSksIC4uLihvbkxvYWQgJiYgeyBvbkxvYWQgfSksIC4uLihvdmVycmlkZVNyYyAmJiB7IG92ZXJyaWRlU3JjIH0pLCAuLi4ocGxhY2Vob2xkZXIgJiYge1xuICAgICAgICAgICAgcGxhY2Vob2xkZXI6IGJsdXJTdHlsZSB8fCBibHVyQ29tcGxldGUgPyBcImVtcHR5XCIgOiBwbGFjZWhvbGRlcixcbiAgICAgICAgfSksIC4uLih1bm9wdGltaXplZCAmJiB7IHVub3B0aW1pemVkIH0pLCAuLi4ocHJpb3JpdHkgJiYgeyBwcmlvcml0eSB9KSwgLi4uKGlzU1ZHICYmIHsgdW5vcHRpbWl6ZWQ6IHRydWUgfSksIHN0eWxlOiB7IC4uLnN0eWxlLCAuLi5ibHVyU3R5bGUgfSwgbG9hZGVyOiBpbWFnZUVycm9yIHx8IHVub3B0aW1pemVkID09PSB0cnVlXG4gICAgICAgICAgICA/ICgpID0+IGZhbGxiYWNrTG9hZGVyKHsgc3JjOiBvdmVycmlkZVNyYyB8fCBzcmMgfSlcbiAgICAgICAgICAgIDogKGUpID0+IG9wdGltaXplZExvYWRlcih7IHNyYywgd2lkdGg6IGUud2lkdGgsIGJhc2VQYXRoIH0pLCBibHVyRGF0YVVSTDogYXV0b21hdGljYWxseUNhbGN1bGF0ZWRCbHVyRGF0YVVSTCwgb25FcnJvcjogKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBzZXRJbWFnZUVycm9yKHRydWUpO1xuICAgICAgICAgICAgc2V0Qmx1ckNvbXBsZXRlKHRydWUpO1xuICAgICAgICAgICAgLy8gZXhlY3V0ZSB0aGUgb25FcnJvciBmdW5jdGlvbiBpZiBwcm92aWRlZFxuICAgICAgICAgICAgb25FcnJvciAmJiBvbkVycm9yKGVycm9yKTtcbiAgICAgICAgfSwgb25Mb2FkOiAoZSkgPT4ge1xuICAgICAgICAgICAgLy8gZm9yIHNvbWUgY29uZmlndXJhdGlvbnMsIHRoZSBvbkVycm9yIGhhbmRsZXIgaXMgbm90IGNhbGxlZCBvbiBhbiBlcnJvciBvY2N1cnJlbmNlXG4gICAgICAgICAgICAvLyBzbyB3ZSBuZWVkIHRvIGNoZWNrIGlmIHRoZSBpbWFnZSBpcyBsb2FkZWQgY29ycmVjdGx5XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBlLnRhcmdldDtcbiAgICAgICAgICAgIGlmICh0YXJnZXQubmF0dXJhbFdpZHRoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gQnJva2VuIGltYWdlLCBmYWxsIGJhY2sgdG8gdW5vcHRpbWl6ZWQgKG1lYW5pbmcgdGhlIG9yaWdpbmFsIGltYWdlIHNyYylcbiAgICAgICAgICAgICAgICBzZXRJbWFnZUVycm9yKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0Qmx1ckNvbXBsZXRlKHRydWUpO1xuICAgICAgICAgICAgLy8gZXhlY3V0ZSB0aGUgb25Mb2FkIGNhbGxiYWNrIGlmIHByZXNlbnRcbiAgICAgICAgICAgIG9uTG9hZCAmJiBvbkxvYWQoZSk7XG4gICAgICAgIH0sIHNyYzogaXNTdGF0aWNJbWFnZSA/IHNyYyA6IF9zcmMgfSkpO1xufSk7XG5FeHBvcnRlZEltYWdlLmRpc3BsYXlOYW1lID0gXCJFeHBvcnRlZEltYWdlXCI7XG5leHBvcnQgZGVmYXVsdCBFeHBvcnRlZEltYWdlO1xuIl0sIm5hbWVzIjpbIkltYWdlIiwiUmVhY3QiLCJmb3J3YXJkUmVmIiwidXNlTWVtbyIsInVzZVN0YXRlIiwic3BsaXRGaWxlUGF0aCIsImZpbGVQYXRoIiwiZmlsZW5hbWVXaXRoRXh0ZW5zaW9uIiwic3BsaXQiLCJwb3AiLCJmaWxlUGF0aFdpdGhvdXRGaWxlbmFtZSIsInNoaWZ0IiwiZmlsZUV4dGVuc2lvbiIsImZpbGVuYW1lV2l0aG91dEV4dGVuc2lvbiIsInN1YnN0cmluZyIsImxhc3RJbmRleE9mIiwicGF0aCIsImZpbGVuYW1lIiwiZXh0ZW5zaW9uIiwiZ2VuZXJhdGVJbWFnZVVSTCIsInNyYyIsIndpZHRoIiwiYmFzZVBhdGgiLCJpc1JlbW90ZUltYWdlIiwidXNlV2VicCIsInByb2Nlc3MiLCJlbnYiLCJuZXh0SW1hZ2VFeHBvcnRPcHRpbWl6ZXJfc3RvcmVQaWN0dXJlc0luV0VCUCIsInVuZGVmaW5lZCIsImluY2x1ZGVzIiwidG9VcHBlckNhc2UiLCJwcm9jZXNzZWRFeHRlbnNpb24iLCJjb3JyZWN0ZWRQYXRoIiwibGFzdENoYXIiLCJzdWJzdHIiLCJpc1N0YXRpY0ltYWdlIiwiZW5kc1dpdGgiLCJzdGFydHNXaXRoIiwic2xpY2UiLCJleHBvcnRGb2xkZXJOYW1lIiwibmV4dEltYWdlRXhwb3J0T3B0aW1pemVyX2V4cG9ydEZvbGRlck5hbWUiLCJiYXNlUGF0aFByZWZpeEZvclN0YXRpY0ltYWdlcyIsImdlbmVyYXRlZEltYWdlVVJMIiwiY2hhckF0IiwiaGFzaEFsZ29yaXRobSIsInN0ciIsInNlZWQiLCJoMSIsImgyIiwiaSIsImNoIiwibGVuZ3RoIiwiY2hhckNvZGVBdCIsIk1hdGgiLCJpbXVsIiwidXJsVG9GaWxlbmFtZSIsInVybCIsInBhcnNlZFVybCIsIlVSTCIsInBhdGhuYW1lIiwidG9TdHJpbmciLCJjb25jYXQiLCJlcnJvciIsImNvbnNvbGUiLCJpbWFnZVVSTEZvclJlbW90ZUltYWdlIiwiZW5jb2RlZFNyYyIsIm9wdGltaXplZExvYWRlciIsIl9zcmMiLCJvcmlnaW5hbEltYWdlV2lkdGgiLCJkZXZpY2VTaXplcyIsIl9fTkVYVF9JTUFHRV9PUFRTIiwibWFwIiwiTnVtYmVyIiwiaW1hZ2VTaXplcyIsImFsbFNpemVzIiwiZmlsdGVyIiwidiIsImEiLCJpbmRleE9mIiwic29ydCIsImIiLCJuZXh0TGFyZ2VzdFNpemUiLCJmYWxsYmFja0xvYWRlciIsIkV4cG9ydGVkSW1hZ2UiLCJwcmlvcml0eSIsImxvYWRpbmciLCJjbGFzc05hbWUiLCJoZWlnaHQiLCJvbkxvYWQiLCJ1bm9wdGltaXplZCIsInBsYWNlaG9sZGVyIiwiYWx0IiwiYmx1ckRhdGFVUkwiLCJzdHlsZSIsIm9uRXJyb3IiLCJvdmVycmlkZVNyYyIsInJlc3QiLCJyZWYiLCJpbWFnZUVycm9yIiwic2V0SW1hZ2VFcnJvciIsImF1dG9tYXRpY2FsbHlDYWxjdWxhdGVkQmx1ckRhdGFVUkwiLCJpc1NWRyIsImJsdXJDb21wbGV0ZSIsInNldEJsdXJDb21wbGV0ZSIsImJsdXJTdHlsZSIsImJhY2tncm91bmRTaXplIiwib2JqZWN0Rml0IiwiYmFja2dyb3VuZFBvc2l0aW9uIiwib2JqZWN0UG9zaXRpb24iLCJiYWNrZ3JvdW5kUmVwZWF0IiwiYmFja2dyb3VuZEltYWdlIiwiY3JlYXRlRWxlbWVudCIsImxvYWRlciIsImUiLCJ0YXJnZXQiLCJuYXR1cmFsV2lkdGgiLCJkaXNwbGF5TmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next-image-export-optimizer/dist/ExportedImage.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next-image-export-optimizer/dist/ExportedImage.js":
/*!************************************************************************!*\
  !*** ./node_modules/next-image-export-optimizer/dist/ExportedImage.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $$typeof: () => (/* binding */ $$typeof),
/* harmony export */   __esModule: () => (/* binding */ __esModule),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/build/webpack/loaders/next-flight-loader/module-proxy */ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-flight-loader/module-proxy.js");

const proxy = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/katelynmei/Documents/Github/web-cse440-24au/node_modules/next-image-export-optimizer/dist/ExportedImage.js`)

// Accessing the __esModule property and exporting $$typeof are required here.
// The __esModule getter forces the proxy target to create the default export
// and the $$typeof value is for rendering logic to determine if the module
// is a client boundary.
const { __esModule, $$typeof } = proxy;
const __default__ = proxy.default;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/katelynmei/Documents/Github/web-cse440-24au/node_modules/next-image-export-optimizer/dist/ExportedImage.js#default`));


/***/ })

};
;